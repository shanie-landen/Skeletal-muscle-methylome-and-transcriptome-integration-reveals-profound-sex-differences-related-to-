library(limma)
library(minfi)
library(bacon)
library(tidyverse)
library(dplyr)
library(openxlsx)
library(readxl)
library(biomaRt)
library(DMRcate)
library(IRanges)
library(dplyr)
library(dplyr)
library(stringr)
library(VennDiagram)


#load three datasets and run linear model for sex- to be used for meta-analysis
#1. GSE38291
GSE38291_M=read.delim('GSE38291_M.txt')
GSE38291_pheno=read.delim('GSE38291_phenotypes.txt')
design=model.matrix(~Age+
                      Sex+ #adjust for sex
                      Status, #adjust for disease state
                    GSE38291_pheno)
corfit <- duplicateCorrelation(GSE38291_M,
                               design,
                               block=GSE38291_pheno$Sibship) #take into account twinship

fit1 <- lmFit(GSE38291_M, #do the analysis on the M-matrix
              design,
              block=GSE38291_pheno$Sibship,
              correlation=0.466569)
fit2 <- eBayes(fit1)

#SE: SE around the slope for age
#ES:change in methylation in males compared to females
#Obtain regression coefficient and p-value for each CpG
results <- topTable(fit2,
                    coef="SexM",
                    number=Inf,
                    p.value=1)
#Obtain standard error
SE <- fit2$sigma * fit2$stdev.unscaled

SE <- SE[rownames(results),"SexM"]
results <- cbind(results,SE)

#Save results, need it in a format good for METAL
CPG <- rownames(results) #name of marker (CpG)
ALLELE1 <- rep(1,nrow(results)) #fake allele info (not important)
ALLELE2 <- rep(2,nrow(results)) #fake allele info (not important)
TESTSTAT <- results$t #t-statistic
PVALUE <- results$P.Value #p-value
EFFECTSIZE <- results$logFC #effect size
SE <- results$SE #standard error
results = data.frame(CPG,
                     ALLELE1,
                     ALLELE2,
                     TESTSTAT,
                     PVALUE,
                     EFFECTSIZE,
                     SE)
write.table(results,
            file="GSE38291.tbl",
            quote = FALSE,
            row.names = FALSE,
            col.names = TRUE,
            sep="\t")

#FUSION data
FUSION_B=read.delim("FUSION_B_xhyb_removed.txt")  #remove cross hybridizing probes
FUSION_pheno=read.delim("FUSION_phenotypes.txt")
FUSION_M=logit2(FUSION_B)

design=model.matrix(~age_biopsy+sex+bmi+smoke_current+ogtt_status,
                     FUSION_pheno)

fit1 <- lmFit(FUSION_M, #do the analysis on the M-matrix
              design)
fit2 <- eBayes(fit1)
results <- limma::topTable(fit2,
                    coef="sexM",
                    number=Inf,
                    p.value=1)
SE <- fit2$sigma * fit2$stdev.unscaled
SE <- SE[rownames(results),"sexM"]
results <- cbind(results,SE)
CPG <- rownames(results) #name of marker (CpG)
ALLELE1 <- rep(1,nrow(results)) #fake allele info (not important)
ALLELE2 <- rep(2,nrow(results)) #fake allele info (not important)
TESTSTAT <- results$t #t-statistic
PVALUE <- results$P.Value #p-value
EFFECTSIZE <- results$logFC #effect size
SE <- results$SE #standard error
results = data.frame(CPG,
                     ALLELE1,
                     ALLELE2,
                     TESTSTAT,
                     PVALUE,
                     EFFECTSIZE,
                     SE)
write.table(results,
            file="FUSION.tbl",
            quote = FALSE,
            row.names = FALSE,
            col.names = TRUE,
            sep="\t")

#Gene SMART data
M_merged_QUT_diagen=read.delim("M_merged_QUT_diagen_xhyb.txt")
merged_pheno=read.delim("merged_pheno.txt")
design <- model.matrix(~sex*Timepoint+Age_PRE+batch,
                       merged_pheno)
corfit <- duplicateCorrelation(M_merged_QUT_diagen,
                               design,
                               block = merged_pheno$ID) #block for duplicate samples (two timepoints per participant)
fit = lmFit(M_merged_QUT_diagen,
            design,
            block=merged_pheno$ID,
            correlation=corfit$consensus) 
fit2 <- eBayes(fit)
results=topTable(fit2,
                      coef = "sexmale",
                      number = nrow(M_merged_QUT_diagen),
                      p.value = 1)
SE <- fit2$sigma * fit2$stdev.unscaled
SE <- SE[rownames(results),"sexmale"]
results <- cbind(results,SE)
CPG <- rownames(results) #name of marker (CpG)
ALLELE1 <- rep(1,nrow(results)) #fake allele info (not important)
ALLELE2 <- rep(2,nrow(results)) #fake allele info (not important)
TESTSTAT <- results$t #t-statistic
PVALUE <- results$P.Value #p-value
EFFECTSIZE <- results$logFC #effect size
SE <- results$SE #standard error
results = data.frame(CPG,
                     ALLELE1,
                     ALLELE2,
                     TESTSTAT,
                     PVALUE,
                     EFFECTSIZE,
                     SE)
write.table(results,
            file="GENESMART.tbl",
            quote = FALSE,
            row.names = FALSE,
            col.names = TRUE,
            sep="\t")

#run the same code as above, for all three datasets, but for the Beta matrices. This will be used for effect sizes. Should have 2 tbls for each dataset (one from M and one from beta)

#List all files ending in "tbl" in the folder
files <- list.files()[grep(".tbl",list.files())]
directory="~/git/git/tbls_for_meta/new tbls"

#Run each file in bacon using a loop
for (f in files)
{
  file <- read_tsv(f) #Read the file
  f <- sub("\\.tbl", "", f) #Obtain the name of the dataset without the ".tbl" at the end
  print(f) #show which dataset we are currently analysing
  bc <- bacon(teststatistics = NULL, #run bacon on effect sizes and standard errors
              effectsizes = file$EFFECTSIZE,
              standarderrors = file$SE)
  #bias and inflation=what it outputs  
  tiff(paste0('QQ-plot_',f,'.tiff'), #save the graph of raw and adjusted effect sizes and standard errors
       width =4,
       height = 2.5,
       units = 'in',
       res=600)
  print(plot(bc, type="qq")) #q-q plot shows the deviation of p-value distribution from null hypothesis. The observed P values for each CpG are sorted from largest to smallest and plotted against expected values from a theoretical ??2-distribution.
  dev.off()
  
  print(c(inflation(bc), #show the inflation factor for this dataset
          bias(bc))) #show the bias factor for this dataset
  
  file$EFFECTSIZE_CORR <- es(bc)[,1] #add a column to the file corresponding to the corrected effect size
  file$SE_CORR <- se(bc)[,1] #add a column to the file corresponding to the corrected standard error
  file$PVALUE_CORR <- pval(bc)[,1] #add a column to the file corresponding to the corrected p-value
  write.table(file, #save the file
              file=paste0(directory,"/",f,"_corrected.tbl"),
              quote = FALSE,
              row.names = FALSE,
              col.names = TRUE,
              sep="\t")
}

#do as above for beta and M, however for beta:
#FOR THE BETA VALUES FILE: METAL doesn't like small values and it will round them up to a point that is no longer exploitable, so before you run METAL (just after bacon), multiply the beta-values adjusted effect sizes and standard errors by 100
FUSION_B_corrected=read.delim("FUSION_B_corrected.tbl")
FUSION_B_corrected$EFFECTSIZE_CORR100=FUSION_B_corrected$EFFECTSIZE_CORR*100
FUSION_B_corrected$SE_CORR_100=FUSION_B_corrected$SE_CORR*100

GENESMART_B_corrected=read.delim("GENESMART_B_corrected.tbl")
GENESMART_B_corrected$EFFECTSIZE_CORR100=GENESMART_B_corrected$EFFECTSIZE_CORR*100
GENESMART_B_corrected$SE_CORR_100=GENESMART_B_corrected$SE_CORR*100

GSE38291_B_corrected=read.delim("GSE38291_B_corrected.tbl")
GSE38291_B_corrected$EFFECTSIZE_CORR100=GSE38291_B_corrected$EFFECTSIZE_CORR*100
GSE38291_B_corrected$SE_CORR_100=GSE38291_B_corrected$SE_CORR*100

#resave the three of them with updated ES and SE
write.table(GSE38291_B_corrected,
            file="GSE38291_B_corrected_final.tbl",
            quote = FALSE,
            row.names = FALSE,
            col.names = TRUE,
            sep="\t")

write.table(FUSION_B_corrected,
            file="FUSION_B_corrected_final.tbl",
            quote = FALSE,
            row.names = FALSE,
            col.names = TRUE,
            sep="\t")

write.table(GENESMART_B_corrected,
            file="GENESMART_B_corrected_final.tbl",
            quote = FALSE,
            row.names = FALSE,
            col.names = TRUE,
            sep="\t")
############################################
###not a part of regular flow, THIS IS FOR REMOVING DIABETICS FROM FUSION to do the sensitivity analysis-
#remove unhealthy people from FUSION and redo tbls and meta for analysis
FUSION_B=read.delim("FUSION_B_xhyb_removed.txt")
FUSION_pheno=read.delim("FUSION_phenotypes.txt")
FUSION_pheno_noT2D=FUSION_pheno %>% filter(ogtt_status!="T2D")
FUSION_B_noT2D=FUSION_B[,colnames(FUSION_B) %in% FUSION_pheno_noT2D$SUBJECT_ID]
design=model.matrix(~age_biopsy+sex+bmi+smoke_current+ogtt_status, #adjust for BMI
                    FUSION_pheno_noT2D)
fit1 <- lmFit(FUSION_B_noT2D, #do the analysis on the M-matrix
              design)
fit2 <- eBayes(fit1)
results <- limma::topTable(fit2,
                           coef="sexM",
                           number=Inf,
                           p.value=1)
SE <- fit2$sigma * fit2$stdev.unscaled
SE <- SE[rownames(results),"sexM"]
results <- cbind(results,SE)
CPG <- rownames(results) #name of marker (CpG)
ALLELE1 <- rep(1,nrow(results)) #fake allele info (not important)
ALLELE2 <- rep(2,nrow(results)) #fake allele info (not important)
TESTSTAT <- results$t #t-statistic
PVALUE <- results$P.Value #p-value
EFFECTSIZE <- results$logFC #effect size
SE <- results$SE #standard error
results = data.frame(CPG,
                     ALLELE1,
                     ALLELE2,
                     TESTSTAT,
                     PVALUE,
                     EFFECTSIZE,
                     SE)
write.table(results,
            file="FUSION_B_noT2D.tbl",
            quote = FALSE,
            row.names = FALSE,
            col.names = TRUE,
            sep="\t")
#same for M
FUSION_M_noT2D=logit2(FUSION_B_noT2D)
design=model.matrix(~age_biopsy+sex+bmi+smoke_current+ogtt_status, #adjust for BMI
                    FUSION_pheno_noT2D)
fit1 <- lmFit(FUSION_M_noT2D, #do the analysis on the M-matrix
              design)
fit2 <- eBayes(fit1)
results <- limma::topTable(fit2,
                           coef="sexM",
                           number=Inf,
                           p.value=1)
SE <- fit2$sigma * fit2$stdev.unscaled
SE <- SE[rownames(results),"sexM"]
results <- cbind(results,SE)
CPG <- rownames(results) #name of marker (CpG)
ALLELE1 <- rep(1,nrow(results)) #fake allele info (not important)
ALLELE2 <- rep(2,nrow(results)) #fake allele info (not important)
TESTSTAT <- results$t #t-statistic
PVALUE <- results$P.Value #p-value
EFFECTSIZE <- results$logFC #effect size
SE <- results$SE #standard error
results = data.frame(CPG,
                     ALLELE1,
                     ALLELE2,
                     TESTSTAT,
                     PVALUE,
                     EFFECTSIZE,
                     SE)
write.table(results,
            file="FUSION_noT2D.tbl",
            quote = FALSE,
            row.names = FALSE,
            col.names = TRUE,
            sep="\t")

#bacon for EWAS inflation
#List all files ending in "tbl" in the folder
files <- list.files()[grep(".tbl",list.files())]
directory="~/git/git/tbls_for_meta/new tbls"
for (f in files)
{
  file <- read_tsv(f) #Read the file
  f <- sub("\\.tbl", "", f) #Obtain the name of the dataset without the ".tbl" at the end
  print(f) #show which dataset we are currently analysing
  bc <- bacon(teststatistics = NULL, #run bacon on effect sizes and standard errors
              effectsizes = file$EFFECTSIZE,
              standarderrors = file$SE)
  #bias and inflation=what it outputs  
  tiff(paste0('QQ-plot_',f,'.tiff'), #save the graph of raw and adjusted effect sizes and standard errors
       width =4,
       height = 2.5,
       units = 'in',
       res=600)
  print(plot(bc, type="qq")) #q-q plot shows the deviation of p-value distribution from null hypothesis. The observed P values for each CpG are sorted from largest to smallest and plotted against expected values from a theoretical ??2-distribution.
  dev.off()  
  print(c(inflation(bc), #show the inflation factor for this dataset
          bias(bc))) #show the bias factor for this dataset  
  file$EFFECTSIZE_CORR <- es(bc)[,1] #add a column to the file corresponding to the corrected effect size
  file$SE_CORR <- se(bc)[,1] #add a column to the file corresponding to the corrected standard error
  file$PVALUE_CORR <- pval(bc)[,1] #add a column to the file corresponding to the corrected p-value
  write.table(file, #save the file
              file=paste0(directory,"/",f,"_corrected.tbl"),
              quote = FALSE,
              row.names = FALSE,
              col.names = TRUE,
              sep="\t")
}

#redo all three of those + bacon for beta values
#FOR THE BETA VALUES FILE: METAL doesn't like small values and it will round them up to a point that is no longer exploitable, so before you run METAL (just after bacon), multiply the beta-values adjusted effect sizes and standard errors by 100
FUSION_B_noT2D_corrected=read.delim("FUSION_B_noT2D_corrected.tbl")
FUSION_B_noT2D_corrected$EFFECTSIZE_CORR100=FUSION_B_noT2D_corrected$EFFECTSIZE_CORR*100
FUSION_B_noT2D_corrected$SE_CORR_100=FUSION_B_noT2D_corrected$SE_CORR*100
write.table(FUSION_B_noT2D_corrected,
            file="FUSION_B_noT2D_corrected_final.tbl",
            quote = FALSE,
            row.names = FALSE,
            col.names = TRUE,
            sep="\t")

#run the METAL softare
#now load meta-analysis results
META_M_noT2D=read.delim("METAANALYSIS_M_noT2D.TBL")
META_B_noT2D=read.delim("METAANALYSIS_B_noT2D.TBL")

# add t-stat for DMRcate
t_statistic=META_M_noT2D$Effect/META_M_noT2D$StdErr
META_M_noT2D$t_stat=t_statistic

#add effect sizes of beta for volcano plot 
META_M_noT2D$BetaEffectSize=META_B_noT2D$Effect

#FIRST filter cpgs that are included in 2 or more studies, but dont filter for direction because that would bias the pval adj that im doing next
META_filtered_noT2D=META_M_noT2D[META_M_noT2D$HetDf>=1,]

#adjust the p value with FDR
FDR=p.adjust(META_filtered_noT2D$P.value, method = "fdr", n = length(META_filtered_noT2D$P.value))
META_filtered_noT2D$FDR=FDR
DMPs_noT2D=META_filtered_noT2D[META_filtered_noT2D$FDR<0.005,]
rownames(DMPs_noT2D)=DMPs_noT2D$MarkerName

#get all of the original DMPs and graph those
DMPs_noT2D=META_filtered_noT2D[META_filtered$FDR<0.005,]
rownames(DMPs_noT2D)=DMPs_noT2D$MarkerName

annotation=read.delim('Annotation_2020.txt',header=TRUE)
rownames(annotation)=annotation$probeID

#add annotation to DMPs
DMPs_noT2D$"probeID"=DMPs_noT2D$MarkerName
DMPs_noT2D=left_join(DMPs_noT2D,annotation,by="probeID")

#graph the DMP effect sizes in a 2D plot, x axis: effext sizes of DMPs from reg analysis, y axis: effect sizes of DMPs from healthy peeps analysis
Effect_sizes_together=inner_join(DMPs,DMPs_noT2D,by="MarkerName")
gg=ggplot(Effect_sizes_together, aes(BetaEffectSize.x, BetaEffectSize.y)) +
  geom_point(aes(color=FDR.y),size=0.1)+
  scale_color_gradientn(name = "FDR w/o T2D analysis", trans = "log", breaks =  c(0.0000000000000005,0.0005,0.005,0.5),limits = c(0.0000000000000005,0.5),colours=c("red","orange","yellow","black"))+
  labs(x="% DNAm difference btwn males compared
       to females (full meta-analysis)",y="% DNAm difference btwn males compared
       to females (w/o T2D meta-analysis)")+
  theme_minimal()+
  labs(color = "FDR w/o T2D 
      analysis")+
  geom_vline(xintercept = 0) + geom_hline(yintercept = 0)+
  theme(legend.title = element_text(size = 8),
        legend.text = element_text(size = 8))

tiff("2D plot of eff sizes in full meta vs meta without T2D.tiff",
     height = 3.5,
     width = 5,
     units = "in",
     res = 600)
gg
dev.off()

######################## end diabetes FUSION sensitivity analysis#####

##BACK TO NORMAL DATA NOT DIABETES DATA.. CONTINUE HERE
#run METAL software for meta analysis with TBLs previously saved
#the corrected values from bacon were used and the meta analysis is complete 
#load the meta analysis results
META_M=read.delim("METAANALYSIS_M.TBL")
META_B=read.delim("METAANALYSIS_B.TBL")

#add t-stat for DMRcate
t_statistic=META_M$Effect/META_M$StdErr
META_M$t_stat=t_statistic

#add effect sizes of beta for volcano plot (currently as a percentage, can divide by 100 if want to)
META_M$BetaEffectSize=META_B$Effect

#FIRST filter cpgs that are included in 2 or more studies
META_filtered=META_M[META_M$HetDf>=1,]

#adjust the p value with FDR 
FDR=p.adjust(META_filtered$P.value, method = "fdr", n = length(META_filtered$P.value))
META_filtered$FDR=FDR
DMPs=META_filtered[META_filtered$FDR<0.005,]
rownames(DMPs)=DMPs$MarkerName

annotation=read.delim('Annotation_2020.txt',header=TRUE)
rownames(annotation)=annotation$probeID

#add annotation to DMPs
DMPs$"probeID"=DMPs$MarkerName
DMPs=left_join(DMPs,annotation,by="probeID")

write.xlsx(DMPs, "Supplementary table DMPs.xlsx", sheetName = "Sheet1",
           col.names = TRUE, row.names = TRUE, append = FALSE)

results_sex=read_excel("META DMPs_xhybr_filtered.xlsx",col_names = TRUE)

#overlap DMRs with V8 of Gtex sex DE genes 
signif_sb_genes=read.delim("signif.sbgenes.txt") #GTEx sex biased genes downloaded from GTEx portal
signif_sb_genes_muscle=signif_sb_genes[signif_sb_genes$tissue=='Muscle_Skeletal',] #filter for skeletal muscle tissue

#remove the suffix
s<-sub("\\..*", "", signif_sb_genes_muscle$gene)
signif_sb_genes_muscle$ensembl_gene_id=s 

# define biomart object
mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")
# query biomart
results <- getBM(attributes = c("chromosome_name","external_gene_name","ensembl_gene_id"),
                 filters = "ensembl_gene_id", values = signif_sb_genes_muscle$ensembl_gene_id,
                 mart = mart)

sexDE_anno=dplyr::left_join(signif_sb_genes_muscle,results) #annotated sex-biased genes from GTEx 

#filter out sex biased genes on X chrom
sexDE_anno=sexDE_anno %>% filter(chromosome_name!="X") # 2689 genes on autosomes; 2866 including X chrom
sexDE_anno$effsize=sexDE_anno$effsize*-1 #convert reference: now in males compared to females, as is DNAm

#how many of the sex biased genes overlap with my DMR genes?
#identify DMRs
CpGs2<-rownames(META_filtered) 
rownames(META_filtered)=as.character(META_filtered$MarkerName)
annotation_overlap_only=annotation[is.element(annotation$probeID,intersect(annotation$probeID,rownames(META_filtered))),]
META_filtered$cpg=rownames(META_filtered)
META_filtered=arrange(META_filtered,cpg)
rownames(META_filtered)=as.character(META_filtered$MarkerName)
annotation_overlap_only_2=arrange(annotation_overlap_only,probeID)
#We need to create a "CpGannotated" object to be used in dmrcate
annotated_only <- GRanges(as.character(annotation_overlap_only_2$CpG_chrm), #chromosome
                          IRanges(start=c(annotation_overlap_only_2$CpG_beg),end=c(annotation_overlap_only_2$CpG_end)), #position on chromosome
                          stat = META_filtered$t_stat, #t-statistic
                          diff = META_filtered$BetaEffectSize, #effect size
                          ind.fdr = META_filtered$FDR, #adjusted p-value
                          is.sig = META_filtered$FDR < 0.005) #p-value threshold
names(annotated_only) <- annotation_overlap_only_2$probeID
annotated_only <- sort(annotated_only)
annotated_only_Canno <- new("CpGannotated",
                            ranges = annotated_only) #create a "CpGannotated" object to be
DMR_only <- dmrcate(annotated_only_Canno,
                    C=2,
                    min.cpgs = 2,
                    lambda=1000) #minimum number of CpGs for a region to be a DMR
results.ranges_only <- extractRanges(DMR_only,
                                     genome = "hg38") #2009 annotation of the human genome was hg19 and the 2013 annotation is hg38, our constructed anno uses hg38
RR_only <-as.data.frame (results.ranges_only) #convert results to df


#annotate DMR results to our own annotation for each CpG, ***create the annotation table from Sarah Voisins Github (https://github.com/sarah-voisin/Annotation-of-Illumina-HumanMethylation-arrays)
library(IlluminaHumanMethylationEPICanno.ilm10b2.hg19)
META_matrix=as.matrix(META_filtered)
RSobject <- RatioSet(META_matrix, annotation = c(array = "IlluminaHumanMethylationEPIC",
                                                 annotation = "ilm10b2.hg19"))
RSanno <- getAnnotation(RSobject)[, c("chr", "pos", "Name",
                                      "UCSC_RefGene_Name","UCSC_RefGene_Group")]
#Change annotation with our annotation
RSanno$pos <- annotation[rownames(META_filtered),"CpG_beg"] #Change hg19 position to hg38 position
RSanno$UCSC_RefGene_Name <- annotation[rownames(RSanno),"genesUniq"] #Change gene names
genes <- as.character(RSanno$UCSC_RefGene_Name)
genes[which(is.na(genes))] <- "" #replace NAs with ""
RSanno$UCSC_RefGene_Name <- genes #Give Gene names
RSanno$UCSC_RefGene_Group <- genes
annotation_GR <- makeGRangesFromDataFrame(annotation,
                                          keep.extra.columns=TRUE,
                                          ignore.strand=FALSE,
                                          seqinfo=NULL,
                                          seqnames.field=c("CpG_chrm"),
                                          start.field="CpG_beg",
                                          end.field=c("CpG_end"),
                                          strand.field="probe_strand",
                                          starts.in.df.are.0based=FALSE)
genesidx <- as.data.frame(findOverlaps(results.ranges_only, annotation_GR))
genesover <- tapply(genesidx$subjectHits, genesidx$queryHits,
                    function(x) annotation_GR$genesUniq_with_enh[x])
op.A <- sapply(genesover, function(l) paste(unique(unlist(strsplit(as.character(l),split=";"))), collapse = ";"))
name.A <- names(genesover)
m.A <- as.numeric(name.A)
M <- length(results.ranges_only)
better_annotation <- rep("", M)
better_annotation[m.A] <- op.A
results.ranges_only$overlapping.genes=better_annotation
newGR=results.ranges_only[results.ranges_only@elementMetadata$Stouffer <0.005&results.ranges_only@elementMetadata$HMFDR <0.005&results.ranges_only@elementMetadata$Fisher<0.005]#filter for significant
newGR$overlapping.genes <- gsub('\\s+', '', newGR$overlapping.genes) # REMOVES WHITE SPACE 
gsub=gsub(',',';',newGR$overlapping.genes)
newGR$overlapping.genes=gsub
DMRgenes=strsplit(as.character(newGR$overlapping.genes),split=";") 
DMRgenes_unlisted=unlist(DMRgenes)
DMRgenes_unique=unique(DMRgenes_unlisted)
#overlap of DMR genes with GTEx sex biased expression genes:
DMR_GTEX_overlap=sexDE_anno[is.element(sexDE_anno$external_gene_name,intersect(sexDE_anno$external_gene_name,DMRgenes_unique)),] 
genes_DMR_GTEX_overlap=unique(DMR_GTEX_overlap$external_gene_name)


#actually do cpgs in DMRs vs cpgs not in DMRs
allDMRcpgs <- sapply(1:length(newGR), function (x) names(subsetByOverlaps(annotated_only, newGR[x])))
allDMRcpgs_unlisted=unlist(allDMRcpgs) #34566 cpgs in DMRs
DMRcpgs_anno=annotation[allDMRcpgs_unlisted,]
DMRgenes=strsplit(as.character(DMRcpgs_anno$genesUniq),split=";")
DMRgenes_unlisted=unlist(DMRgenes)
DMRgenes_unique=unique(DMRgenes_unlisted) 
DMR_GTEX_overlap=sexDE_anno[is.element(sexDE_anno$external_gene_name,intersect(sexDE_anno$external_gene_name,DMRgenes_unique)),]
genes_DMR_GTEX_overlap=unique(DMR_GTEX_overlap$external_gene_name) #1118 genes in overlap between cpgs in DMRs and sexbiased gtex out of 10161 total genes annotated to cpgs in DMRs (a little diff than genes annotated to DMRs directly)
length(DMRgenes_unique)  

#venn of overlapping DMGs with DEGs
DMRgenes_unique=na.omit(DMRgenes_unique) #remove NAs

#identify Differentially expressed genes from FUSION
top.table_noXY=read.xlsx("DEGs FUSION.xlsx")
DEGs_FUSION=unique(top.table_noXY$external_gene_name)
DEGs_GTEX=unique(sexDE_anno$external_gene_name)

venn.diagram(
  x = list(DMRgenes_unique, DEGs_GTEX,DEGs_FUSION),
  category.names = c("DMGs",
                     "DEGs GTEx",
                     "DEGs FUSION "),
  filename = "VennD DEGs DMGs FUSION.tiff",
  output=TRUE,
  col=c("#440154ff", '#21908dff','#fde725ff'),
  cex=2,
  lwd=1.2,
 fill = c("#440154ff", '#21908dff','#fde725ff'),
  cat.cex = 1.5,
  cat.default.pos = "outer",
  cat.pos = c(-10, 10,180),
  cat.dist = c(0.05, 0.05,0.05),
  scaled=FALSE,
  resolution=600
)
